h1. UrlMount

UrlMount is a universal mount point designed for use in rack applications.

It provides a simple way to pass a url mounting point to the mounted application.

This means that when you mount an application in the url space, it's a simple to_s to get the mount point of where the application is.

h2. Example

Say you mount an application at "/foo/bar"

<pre><code>router.mount("/foo/bar").to(my_app)

# behind the scenes, the routers mount method should do this:

  if my_app.respond_to?(:url_mount=)
    mount_point = UrlMount.new("/foo/bar")
    my_app.url_mount = mount_point
  end
</code></pre>

This means that if an application can handle a url_mount, you give it one.

This then allows the +my_app+ applciation, to know where it's mounted.  Generating a url is now as simple as
<pre><code>File.join(url_mount.to_s, "/local/url/path")</code></pre>

The benefit of this is that all routers or applciations can make use of this.  If used, it can act as a universal glue between rack applications where parent apps can let the child applications know where they're mounted.

h3. Show me the code

urlmount is made to be used with many routers that are currently available.

<pre><code>
# simple string mounting point
mount = urlmount.new("/foo/bar")
mount.to_s == "/foo/bar"

# Mount Point including variables
mount = UrlMount.new("/foo/:bar")
mount.to_s(:bar => "something") == "/foo/something"
mount.to_s #=> Raises UrlMount::Ungeneratable because a required variable was not found
mount.required_variables == [:bar]

# Mount Point including optional variables
mount = UrlMount.new("/foo/:bar(/:baz)")
mount.to_s(:bar => "doh") == "/foo/doh"
mount.to_s(:bar => "doh", :baz => "hah") == "/foo/doh/hah"
mount.required_variables == [:bar]
mount.optional_variables == [:baz]

# Mount Point with defaults
mount = UrlMount.new("/foo/:bar(/:baz)", :bar => "default_bar")
mount.to_s == "/foo/default_bar"
mount.to_s(:baz => "baz_value") == "/foo/default_bar/baz_value"
mount.to_s(:bar => "other_bar") == "/foo/other_bar"

# Nested mounting point
mount_parent = UrlMount.new("/foo/bar")
mount_child  = UrlMount.new("/baz/:barry)

mount_child.url_mount = mount_parent

mount_parent.to_s == "/foo/bar"
mount_child.to_s(:barry =>"barry_value") == "/foo/bar/baz/barry_value"
</code></pre>

Considering that UrlMounts can be nested, when you mount an application you should do it something like this.

<pre><code>
if mounted_app.respond_to?(:url_mount=)
  mount = UrlMount.new(path, deafult_options)

  # If this app is mounted, add this apps mount point to
  # the mount point for the child app
  mount.url_mount = self.url_mount if self.url_mount

  mounted_app.url_mount = mount
end
</code></pre>

h2. Note on Patches/Pull Requests

* Fork the project.
* Make your feature addition or bug fix.
* Add tests for it. This is important so I don't break it in a
  future version unintentionally.
* Commit, do not mess with rakefile, version, or history.
  (if you want to have your own version, that is fine but bump version in a commit by itself I can ignore when I pull)
* Send me a pull request. Bonus points for topic branches.

h2. Copyright

Copyright (c) 2010 Daniel Neighman. See LICENSE for details.
